# 불필요한 객체 생성을 피하라
같은 객체를 매번 생성하지 말고 재사용하자,
특히, 불변 객체(아이템17)는 언제든 재사용할 수 있다.

## 1. String
```java
    String s = new String("cup"); // 따라하지말 것
```
실행될 때마다 String 인스턴스를 새로 만듦

```java
    String S = "cup";
```
인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용함
같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 사용함이 보장됨

## 2. 불변 클래스에서의 정적 팩터리 메서드 사용
생성자는 호출할 때마다 새로운 객체를 만들지만 팩터리 메서드는 그렇지 않음

Boolean(String) 생성자 대신 Boolean.valueOf(String) 팩터리 메서드를 사용하는 것이 좋음

## 3. 비싼 객체는 캐싱하여 사용하자.
매번 명확히 비싼 객체인지 알기는 어렵다.

ex) 문자열이 유효한 로마 숫자인지 확인하는 메서드 - 정규표현식<br>
**코드 6-1. 성능을 훨씬 더 끌어올릴 수 있다**
```java
static boolean isRomanNumeral(String s){
    return s.matches("....");
}
```
문제점 : String.matches 메서드
- Pattern 인스턴스는 한 번 쓰고 버려지는 가비지 컬렉션 대상<br>

성능 개선 : 정규표현식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고,
나중에 isRomanNumeral 메서드가 호출될 때마다 인스턴스 재사용

**코드6-2. 값비싼 객체를 재사용해 성능을 개선**
```java
static class RomanNumerals{
    private static final Pattern ROMAN = Pattern.compile(/**정규표현식**/);
    
    static boolean isRomanNumeral(String s){
        return ROMAN.matcher(s).matches();
    }
}
```
isRomanNumeral이 번번히 호출되는 상황에서 성능 끌어올릴 수 있음<br>
작은 문제점 : isRomanNumeral 방식의 클래스가 초기화된 후 메서드를 한 번도 호출하지 않는다면 ROMAN은 쓸데없이 초기화된 것임
- 지연 초기화(아이템83)을 사용하여 불필요한 초기화를 없앨 수 있지만 코드 복잡도가 올라가기에 권장하지 않는다고 함

## 4. 불변 객체가 단점이 될 때
덜 명확하거나, 직관에 반대되는 상황(?)<br>
예시 : 어댑터(view)
- 뒷단 객체 외에는 관리할 상태 없으므로 뒷단 객체 하나당 어댑터 하나만 만들면 됨
- ex) Map 인터페이스의 keySet : 키 전부를 담은 Set 뷰 반환
  - 같은 Set 인스턴스를 반환함
  - 반환 객체 하나를 수정하면 다른 모든 객체가 바뀜
- ex) 오토박싱 : 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 변환해주는 기술
  - 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지면, 완전히 없애주는 것 X
  - 의미상으론 차이 없어도 성능에서 차이보임
  
**코드6-3. 끔찍이 느리다! 객체가 만들어지는 위치는?**
```java
private static long sum(){
    Long sum = 0L;
    for(long i = 0; i <= Integer.MAX_VALUE; i++){
        sum += i;
    }
    return sum;
}
```
- sum 변수를 long이 아닌 Long으로 선언한 것이 문제
  - long 타입인 i가 Long 타입인 sum에 더해질 때마다 인스턴스가 생성됨
  - sum 타입을 long으로만 바꿔도 빨라짐

**박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱을 주의하자**

## 결론
아주 무거운 객체가 아닌 다음에는 객체 풀을 직접 만들지 말자.
일반적으로는 자체 객체 풀은 코드를 헷갈리게 만들고, 메모리 사용량을 늘리고 성능을 떨어뜨린다. 
요즘 JVM의 가비지 컬렉터는 상당히 잘 최적화되어 있다.

추후 방어적 복사(아이템50)에서 객체를 재사용했을 때의 피해를 알려주는데,
**방어적 복사에 실패하면 버그와 보안 구멍으로 이어지지만, 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 줌을 명심하자.**