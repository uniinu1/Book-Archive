클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public  생성자다. 
하지만 **클래스는 생성자와 별도로 정적 팩터리 메서드(static factory method)를 제공할 수 있다.**

```java
public static Boolean valueOf(boolean b){
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

# 장점
## 1. 이름을 가질 수 있다.
생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다. 생성자는 class명과 동일하게 써야하기 때문. 하지만 정적 팩터리는 이름을 지을 수 있다.

또한 하나의 시그니처로는 생성자를 하나만 만들 수 있다.
이게 무슨 말이냐면 같은 입력 매개변수로 생성자를 하나만 만들 수 있다는 이야기이다. 입력 매개변수들의 순서를 다르게 한 생성자를 새로 추가하는 식으로 제한을 피해볼 수도 있지만, 좋지 않은 발상이다. 그런 API를 사용하는 개발자는 각 생성자가 어떤 역할을 하는지 정확히 기억하기 어려워 엉뚱한 것을 호출하는 실수를 할 수 있다.

## 2. 호출될 때마다 인스턴스를 새로 생성하지  않아도 된다.
- 불필요한 객체 생성을 피할 수 있음
- 같은 객체가 자주 요청되는 상황이면 성능을 끌어올려줌
- 플라이웨이트 패턴도 이와 비슷한 기법임
- 언제 어느 인스턴스를 살아 있게 할지 통제할 수 있어서 이를 인스턴스 통제 클래스라 한다.
  - 통제 이유
    - 클래스를 싱글턴(아이템3)으로 만들 수도, 인스턴스화 불가(아이템4)로도 반들 수 있다.
    - 불변 값 클래스(아이탬17)에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다(a == b일 때만 a.equals(b)가 성립)
    - 플라이웨이트 패턴의 근간이 되며, 열거 타입(아이템34)은 인스턴스가 하나만 만들어짐을 보장함
  
## 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
반환할 객체의 클래스를 자유롭게 선택할 수 있게 하여 '엄청난 유연성'을 선물한다.
API를 만들 때 구현 클래스를 공개하지 않고도 객체를 반환할 수 있어서 API를 작게 유지할 수있다.(메서드의 반환 타입을 정적 팩터리 메서드 반환 타입으로 사용하는 인터페이스 기반 프레임워크(아이템20)를 만드는 핵심 기술이다.)
- java.util.Collections?
- 자바9에서는 privatte 정적 메서드까지 허락하지만 정적 필드와 정적 멤버 클래스는 여전히 public이어야 한다.
  

## 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없음
- 심지어 다음 릴리스에서는 또 다른 클래스의 객체를 반환해도 됨
- EnumSet 클래스는 원소 수에 따라 하위 클래스 중 하나의 인스턴스를 반환함
  - 원소 수 64개 이하 : long 변수 하나로 관리하는 RegularEnumSet
  - 원소 수 65개 이상 : long 배열 JumboEnumSet

## 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
장점 3, 4와 비슷한 개념이다. 이러한 유연성을 제공하는 static 팩토리 매소드는 **서비스 프로바이더** 프레임워크의 근본이다. JDBC를 예로 들고 있다.

서비스 프로바이더 프레임워크는 서비스의 구현체를 대표하는 서비스 인터페이스와 구현체를 등록하는데 사용하는 프로바이더 등록 API 그리고 클라이언트가 해당 서비스의 인스턴스를 가져갈 때 사용하는 서비스 엑세스 API가 필수로 필요하다. 부가적으로 서비스 인터페이스의 인스턴스를 제공하는 서비스 프로바이더 인터페이스를 만들 수도 있는데, 그게 없는 경우에는 리플렉션을 사용해서 구현체를 만들어 준다.

JDBC의 경우, driverManager.registerDriver()가 프로바이더 등록 API. DriverManager.getConenction()이 서비스 엑세스 API 그리고 dRIVER가 서비스 프로바이더 인터페이스 역할을 한다. 

자바6부터는 java.util.ServiceLoader라는 일반적인 용도의 서비스 프로바이더를 제공하지만, JDBC가 그보다 이전에 만들어졌기 대문에 JDBC는 ServiceLoader를 사용하진 않는다.

# 단점
## 1. public 또는 protected 생성자 없이 static public 메소드만 제공하는 클래스는 상속할 수 없다.
따라서, Collections 프레임워크에서 제공하는 편의성 구현체(java.util.Collections)는 상속할 수 없다. 오히려 불변 타입(아이템17)인 경우 상속 대신 컴포지션을 권장(아이템18)하기 때문에 장점이라 말할지도 모르겠다.

## 2. 프로그래머가 static 팩토리 메소드를 찾는게 어렵다.
생성자는 Javadoc 상단에 모아서 보여주지면 static 팩토리 메소드는 API 문서에서 특별히 다뤄주지 않는다. 따라서 클래스나 인터페이스 문서 상단에 팩토리 메소드에 대한 문서를 제공하는 것이 좋겠다.
